### 事件循环

1. 所有同步任务都在主线程上执行，形成一个执行栈。
2. 主线程之外，还存在一个任务队列；只要异步任务有了运行结果，就在任务队列之中放置一个事件。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将队列中的事件放到执行栈中依次执行。
4. 主线程从任务队列中读取事件，这个过程是循环不断地。

基本概念：不管是新用户的请求，还是老用户的IO完成，都将以事件方式加入事件环，等待调度。

### Node运行过程

1. 我们写的代码会交给V8引擎进行处理
2. 代码中间可能会调用nodeAPI,node会交给libuv库处理
3. libuv通过阻塞I/O和多线程实现了异步IO
4. 通过事件驱动的方式，将结果放到事件队列中，最终交给我们的应用。

### 同步和异步

同步和异步关心的消息通知机制：

* 同步的调用者会主动等待这个调用结果。
* 异步的过程调用发出后，调用者不会立刻得到结果，而是调用发出后，被调用者通过状态，通知回调函数处理这个调用。

### 阻塞与非阻塞

阻塞与非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：

* 阻塞调用：指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。
* 非阻塞调用：在不能立即得到结果之前，该调用不会阻塞当前线程。

### 非阻塞调用具体执行细节

当某个IO执行完毕时，将以事件的形式通知执行IO操作的线程，线程执行这个事件的回调函数。为了处理异步IO，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。

如果在阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。

而非阻塞模式下，一个线程永远在执行运行操作，这个线程的CPU核心利用率永远是100%。

注意点：非阻塞和阻塞没有哪个更好，只有更适用场景的选择。
