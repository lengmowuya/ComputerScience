
### 上下文及作用域链
上下文的产生是依赖于作用域的产生的，而作用域的产生依赖于函数及全局对象。当函数执行完毕，相应的作用域及其作用域里的变量都会销毁。

### 块级作用域
ES6新增了let变量声明和块级作用域以相互配合使用，不同于以往只有全局作用域和函数作用域，现在if内，while内都可以拥有一个作用域，你甚至可以不借助任何逻辑的写下一个{}来创建一个块级作用域。

### const定死值和对象
const声明的变量不能修改，因为不能修改，所以const语法定死了在声明时必须对其赋值，否则其没有意义。而因为对象是一个引用值，所以const声明是一个对象时，虽然该变量不能被更改，但是引用的对象其中的键值是可以任意修改的，也并不与const的设计理念相违背。
const的出现有效的缓解了一部分开发规范的提出并降低了很多维护人员和编写人员的精力与成本。建议大家尽量多的使用const.

### Object.freeze()冻结指定对象
如上面所说const不会锁死变量引用的对象的键值修改，所以如果我们想要锁死对象里所有的键值时，我们可以使用Object.freeze()冻结指定的对象。当我们后期修改冻结后的对象时，不会弹出报错，但是会静默失败。
需要注意的误区是，Object.freeze的冻结对象具体含义是，指定对象的所有子键值对会被冻结，不可修改。所以如果指定对象的一个键值对是引用一个对象，那么该对象的键值对还是自由修改与正常无异的。
详细测试见
- [Object.Freeze测试源码]](./Object.Freeze测试.html)


### 值类型的包装
为了便于基本值类型自调用方法，ES6为三种基本的值(Number,String,Boolean)类型提供了包装，以便于调用该类型相关的一些方法。而包装是JS自动的一种机制，开发者无需手动包装，而是在对基本属性自调用方法时，浏览器会自动将基本值包装成一个可以调用方法的对象。而在调用完方法后，后台会自动销毁新创建的对象，整个过程丝滑自然。

```
// 如同代码:
let s1 = new String("some text");
let s2 = s1.substring(2);
s1 = null;
```

### 迭代字符串
在ES6中，自动包装后的字符串的原型上拥有@@iterator方法，可以迭代字符串的每个字符。
```
let message = "abc"
let stringIterator = message[Symbol.iterator]();
console.log(stringIterator.next());
// 使用next方法以继续轮询到下一个字符
console.log(stringIterator.next());
```
而使用for-of可以自动进行迭代
```
for(let char of "Hello,World!"){
    console.log(char);
}
```

### 全局作用域
全局作用域是依赖于网页而产生的，所以全局作用域并不是唯一的，当网页产生多个时，就具有多个全局作用域。



